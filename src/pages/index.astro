---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
---

<Layout title="Home" description="Deep technology innovation and investing.">
	<Header currentPath="/" />
	
	<main class="main">
		<section class="hero">
			<div class="tesseract-container">
				<canvas id="tesseract-canvas"></canvas>
			</div>
			<div class="hero-container">
				<div class="hero-content">
					<h1 class="hero-title">We're betting on deep technology innovation and adoption from the birthplace of Silicon Valley.</h1>
					<p class="hero-subtitle">Novana's Stanford-based team produces in-house technology analyses, investment research briefs, and market trend writeups across edge computing, biotechnology, artificial intelligence, and other frontier technology industries.</p>
				</div>
			</div>
		</section>
	</main>
	
	<!-- Team Section -->
	<section class="team-cta-section">
		<div class="team-cta-container">
			<div class="team-cta-content">
				<p class="team-cta-text">We bring together scientific domain knowledge and end-to-end investment management expertise to produce empirically sound findings for those looking to invest in the future.</p>
				<a href="/about" class="team-cta-button">Meet the Team</a>
				
				<!-- Venn Diagram -->
				<div class="venn-diagram">
					<div class="venn-content">
						<div class="venn-visual">
							<svg viewBox="0 0 380 420" class="venn-svg">
								<!-- Top left circle -->
								<circle cx="110" cy="135" r="99" class="venn-circle" id="domain-circle" />
								<text x="105" y="125" class="venn-label">DOMAIN</text>
								<text x="105" y="140" class="venn-label">KNOWLEDGE</text>
								
								<!-- Top right circle -->
								<circle cx="280" cy="135" r="99" class="venn-circle" id="investment-circle" />
								<text x="285" y="125" class="venn-label">INVESTMENT</text>
								<text x="285" y="140" class="venn-label">EXPERTISE</text>
								
								<!-- Bottom left circle -->
								<circle cx="110" cy="305" r="99" class="venn-circle" id="stanford-circle" />
								<text x="105" y="305" class="venn-label">STANFORD-</text>
								<text x="105" y="320" class="venn-label">BASED</text>
								
								<!-- Bottom right circle -->
								<circle cx="280" cy="305" r="99" class="venn-circle" id="relationships-circle" />
								<text x="285" y="315" class="venn-label">RELATIONSHIPS</text>
								
								<!-- Center circle -->
								<circle cx="195" cy="210" r="60" class="venn-center" />
								<text x="195" y="212" class="venn-center-label">NOVANA</text>
							</svg>
						</div>
						
						<div class="venn-text">
							<div class="venn-description" id="domain-text">
								<p>We're researchers at heart, with competent domains spanning cancer metabolism, ultrasound drug uncaging, spatial omics, ophthalmology diagnostics, and artificial intelligence</p>
							</div>
							
							<div class="venn-description" id="investment-text">
								<p>Our investment management framework is the result of past professional experiences in long-only fundamental equities, enterprise-grade systematic investment strategy design, and buy-side equities trading</p>
							</div>
							
							<div class="venn-description" id="relationships-text">
								<p>We maintain deep, durable relationships across the Bay Area and East Coast, including those with scientific researchers, technical student-founders, venture investors, and asset management executives</p>
							</div>
							
							<div class="venn-description" id="stanford-text">
								<p>We have unparalleled access to Stanford's research faculty, student founders, and startup ecosystem, allowing us to source scientific innovations well before they enter venture or public market pipelines</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>
	
	<Footer />
</Layout>

<script>
	class FlowingPointCloud {
		constructor() {
			this.canvas = document.getElementById('tesseract-canvas');
			this.ctx = this.canvas.getContext('2d');
			
			// Full page canvas
			this.resizeCanvas();
			
			// Generate flowing point cloud
			this.pointCloud = this.generateFlowingPoints();
			
			// Animation parameters
			this.time = 0;
			this.waveSpeed = 0.007; // Increased from 0.005
			
			// Performance monitoring
			this.frameCount = 0;
			this.lastTime = performance.now();
			
			this.setupCanvas();
			this.animate();
			
			// Handle window resize
			window.addEventListener('resize', () => this.resizeCanvas());
			
			// Listen for theme changes
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
						// Theme changed, canvas will update on next frame
					}
				});
			});
			observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
		}
		
		resizeCanvas() {
			const devicePixelRatio = window.devicePixelRatio || 1;
			
			// Get hero section dimensions instead of window dimensions
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Set logical size to hero dimensions
			this.canvas.style.width = heroWidth + 'px';
			this.canvas.style.height = heroHeight + 'px';
			
			// Set actual canvas size accounting for device pixel ratio
			this.canvas.width = heroWidth * devicePixelRatio;
			this.canvas.height = heroHeight * devicePixelRatio;
			
			// Scale the context to match device pixel ratio
			this.ctx.scale(devicePixelRatio, devicePixelRatio);
			
			console.log(`Canvas: ${heroWidth}x${heroHeight} logical, ${this.canvas.width}x${this.canvas.height} physical, DPR: ${devicePixelRatio}`);
			
			// Regenerate points when window size changes significantly for consistent coverage
			const newArea = heroWidth * heroHeight; // Use hero dimensions for area calculation
			const oldArea = this.lastArea || newArea;
			const areaChange = Math.abs(newArea - oldArea) / oldArea;
			
			if (areaChange > 0.2) { // Regenerate if area changed by more than 20%
				console.log('Significant size change detected, regenerating points for consistent coverage...');
				this.pointCloud = this.generateFlowingPoints();
				this.lastArea = newArea;
			}
		}
		
		setupCanvas() {
			this.ctx.imageSmoothingEnabled = true;
			this.ctx.imageSmoothingQuality = 'high';
		}
		
		// Generate flowing, organic point cloud
		generateFlowingPoints() {
			const points = [];
			
			// Get hero section dimensions
			const heroSection = document.querySelector('.hero');
			const screenWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const screenHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Calculate spacing based on hero section size to maintain visual density
			const screenDiagonal = Math.sqrt(screenWidth*screenWidth + screenHeight*screenHeight);
			const referenceDiagonal = Math.sqrt(1920*1920 + 1080*1080); // Reference: 1920x1080
			const scaleFactor = screenDiagonal / referenceDiagonal;
			
			// Detect mobile device for performance optimization
			const isMobile = window.innerWidth <= 768;
			const mobileReduction = isMobile ? 0.5 : 1.0; // Reduce density by 50% on mobile
			
			// Reduced density for better performance - larger spacing
			const baseGridSize = 80 * mobileReduction; // Further reduced on mobile
			const gridSize = Math.floor(baseGridSize * scaleFactor);
			const baseSpacing = (1.0 / mobileReduction); // Increased spacing on mobile
			const mainSpacing = baseSpacing * scaleFactor;
			const secondarySpacing = mainSpacing * 1.8; // Increased from 1.5
			
			console.log(`Hero: ${screenWidth}x${screenHeight} logical, Scale factor: ${scaleFactor.toFixed(2)}, Mobile: ${isMobile}, Grid: ${gridSize}, Spacing: ${mainSpacing.toFixed(2)}`);
			
			// Create wave surfaces - reduced density for better performance
			const waveAmplitude = 2.0;
			
			// Main wave surface - reduced density for performance
			for (let x = -gridSize; x <= gridSize; x += mainSpacing) {
				for (let y = -gridSize; y <= gridSize; y += mainSpacing) {
					// Create wave height based on position
					const distance = Math.sqrt(x*x + y*y);
					const baseZ = Math.sin(distance * 0.15) * waveAmplitude * Math.exp(-distance * 0.015);
					
					// Add multiple wave components for richer pattern
					const wave1 = Math.sin(x * 0.1) * 0.6;
					const wave2 = Math.cos(y * 0.08) * 0.5;
					const wave3 = Math.sin((x + y) * 0.05) * 0.4;
					const wave4 = Math.cos((x - y) * 0.06) * 0.3;
					const wave5 = Math.sin(x * 0.12 + y * 0.07) * 0.35;
					const wave6 = Math.cos(distance * 0.08) * 0.25;
					
					const z = baseZ + wave1 + wave2 + wave3 + wave4 + wave5 + wave6;
					
					points.push({
						baseX: x * 0.12,
						baseY: y * 0.12,
						baseZ: z,
						gridX: x,
						gridY: y,
						amplitude: 0.8
					});
				}
			}
			
			// Add secondary wave surface - reduced density for performance
			for (let x = -gridSize; x <= gridSize; x += secondarySpacing) {
				for (let y = -gridSize; y <= gridSize; y += secondarySpacing) {
					const distance = Math.sqrt(x*x + y*y);
					const baseZ = Math.cos(distance * 0.12 + Math.PI/4) * waveAmplitude * 0.8 * Math.exp(-distance * 0.012);
					
					// Additional wave components for secondary surface
					const wave1 = Math.cos(x * 0.09) * 0.5;
					const wave2 = Math.sin(y * 0.06) * 0.4;
					const wave3 = Math.sin((x * 2 + y) * 0.04) * 0.3;
					const wave4 = Math.cos((x + y * 2) * 0.05) * 0.25;
					
					const z = baseZ + wave1 + wave2 + wave3 + wave4 + 1.2;
					
					points.push({
						baseX: x * 0.12,
						baseY: y * 0.12,
						baseZ: z,
						gridX: x,
						gridY: y,
						amplitude: 0.6,
						isSecondary: true
					});
				}
			}
			
			// Add wave disturbances - reduced count for performance, especially on mobile
			const disturbanceCount = Math.floor(6 * Math.min(scaleFactor, 1.0) * mobileReduction); // Reduced on mobile
			const disturbanceSpacing = secondarySpacing * 1.5; // Increased spacing
			
			for (let i = 0; i < disturbanceCount; i++) {
				const centerX = (Math.random() - 0.5) * gridSize * 1.5;
				const centerY = (Math.random() - 0.5) * gridSize * 1.5;
				const radius = (20 + Math.random() * 15) * scaleFactor; // Slightly smaller radius
				
				for (let x = centerX - radius; x <= centerX + radius; x += disturbanceSpacing) {
					for (let y = centerY - radius; y <= centerY + radius; y += disturbanceSpacing) {
						const dist = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
						if (dist <= radius) {
							const ripple = Math.cos(dist * 0.3) * (1 - dist/radius) * 1.0;
							
							points.push({
								baseX: x * 0.12,
								baseY: y * 0.12,
								baseZ: ripple,
								gridX: x,
								gridY: y,
								amplitude: 0.5,
								disturbance: i
							});
						}
					}
				}
			}
			
			console.log(`Generated ${points.length} wave surface points (optimized for performance${isMobile ? ', mobile' : ''})`);
			return points;
		}
		
		// Project 3D to 2D screen coordinates
		project3DTo2D(x, y, z) {
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			const scale = Math.min(heroWidth, heroHeight) * 0.15; // Use hero dimensions
			const centerX = heroWidth / 2; // Use hero dimensions
			const centerY = heroHeight / 2;
			
			// Perspective projection - no rotation to prevent gaps
			const distance = 8;
			const projectedScale = scale / (1 + z / distance);
			
			return [
				centerX + x * projectedScale,
				centerY - y * projectedScale,
				z
			];
		}
		
		// Draw point with wave surface appearance - enhanced shadows and contrast
		drawPoint(x, y, z, intensity = 1, pointType = 'normal') {
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// More aggressive culling for performance
			if (x < -10 || x >= heroWidth + 10 || y < -10 || y >= heroHeight + 10) return; // Use hero dimensions
			
			// Simplified point size calculation
			let baseSize = 0.7; // Slightly smaller for performance
			if (pointType === 'secondary') baseSize = 0.5;
			if (pointType === 'disturbance') baseSize = 0.6;
			
			const depthSize = Math.max(0.2, baseSize + (5 - z) * 0.08);
			
			// Enhanced shadow calculation for dramatic fold contrast
			const baseIntensity = intensity * 0.85; // Slightly reduced base for more shadow range
			
			// More dramatic depth-based shadows - deeper valleys get much darker
			const depthFactor = Math.max(0.15, Math.min(1.0, 0.9 - z / 8)); // Increased depth sensitivity
			
			// Secondary shadow based on wave position for fold enhancement
			const foldShadow = Math.max(0.6, 1.0 - Math.abs(z) * 0.3); // Deeper folds get darker
			
			const finalIntensity = baseIntensity * depthFactor * foldShadow;
			
			// Theme-aware point colors
			const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
			let darkness;
			
			if (isDark) {
				// In dark mode, use light colors (inverse of light mode)
				darkness = Math.floor(finalIntensity * 200) + 55; // Range: 55 to 255 (light colors)
			} else {
				// In light mode, use dark colors
				darkness = Math.floor((1 - finalIntensity) * 250) + 5; // Range: 5 to 255 (dark colors)
			}
			
			this.ctx.fillStyle = `rgb(${darkness}, ${darkness}, ${darkness})`;
			this.ctx.globalAlpha = 0.6;
			
			// Draw point - no stroke for performance
			this.ctx.beginPath();
			this.ctx.arc(x, y, depthSize, 0, Math.PI * 2);
			this.ctx.fill();
		}
		
		update() {
			// Performance monitoring
			this.frameCount++;
			const currentTime = performance.now();
			if (currentTime - this.lastTime >= 1000) {
				console.log(`FPS: ${this.frameCount}, Points: ${this.pointCloud.length}`);
				this.frameCount = 0;
				this.lastTime = currentTime;
			}
			
			// Get hero section dimensions
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Clear canvas with theme-aware background
			const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
			this.ctx.fillStyle = isDark ? '#0f0f0f' : '#ffffff';
			this.ctx.fillRect(0, 0, heroWidth, heroHeight); // Use hero dimensions
			
			// Apply wave motion to all points - NO ROTATION
			const wavePoints = this.pointCloud.map(point => {
				// Create traveling wave motion with more wave components
				const wavePhase = this.time * 3;
				
				// Multiple wave components for richer motion
				const wave1 = Math.sin(point.gridX * 0.3 + wavePhase) * 0.3;
				const wave2 = Math.cos(point.gridY * 0.25 + wavePhase * 0.8) * 0.25;
				const wave3 = Math.sin((point.gridX + point.gridY) * 0.2 + wavePhase * 1.2) * 0.2;
				const wave4 = Math.cos((point.gridX - point.gridY) * 0.15 + wavePhase * 0.6) * 0.15;
				const wave5 = Math.sin(point.gridX * 0.35 + point.gridY * 0.18 + wavePhase * 1.5) * 0.18;
				const wave6 = Math.cos(point.gridY * 0.28 - point.gridX * 0.12 + wavePhase * 0.9) * 0.12;
				const wave7 = Math.sin((point.gridX * 2 + point.gridY) * 0.08 + wavePhase * 2.0) * 0.1;
				
				// Combine base position with enhanced wave motion
				const flowX = point.baseX;
				const flowY = point.baseY;
				const flowZ = point.baseZ + wave1 + wave2 + wave3 + wave4 + wave5 + wave6 + wave7;
				
				let pointType = 'normal';
				if (point.isSecondary) pointType = 'secondary';
				if (point.disturbance !== undefined) pointType = 'disturbance';
				
				return {
					x: flowX,
					y: flowY,
					z: flowZ,
					pointType: pointType
				};
			});
			
			// Project to 2D with aggressive culling for performance
			const projectedPoints = wavePoints.map(point => {
				const [x, y, z] = this.project3DTo2D(point.x, point.y, point.z);
				return {
					x, y, z,
					pointType: point.pointType
				};
			}).filter(point => {
				// Very aggressive culling for performance
				return point.x > -30 && point.x < heroWidth + 30 && 
				       point.y > -30 && point.y < heroHeight + 30;
			}).sort((a, b) => a.z - b.z);
			
			// Draw all points with simplified intensity calculation
			for (const point of projectedPoints) {
				// Simplified pulse calculation for performance
				const pulse = 0.7 + Math.sin(this.time * 2 + point.x * 0.005 + point.y * 0.005) * 0.3;
				
				this.drawPoint(point.x, point.y, point.z, pulse, point.pointType);
			}
			
			// Reset alpha
			this.ctx.globalAlpha = 1;
			
			// Update time
			this.time += this.waveSpeed;
		}
		
		animate() {
			this.update();
			requestAnimationFrame(() => this.animate());
		}
	}
	
	// Initialize when page loads
	document.addEventListener('DOMContentLoaded', () => {
		new FlowingPointCloud();
		
		// Initialize Venn diagram scroll interactions
		initVennScrollInteractions();
	});
	
	function initVennScrollInteractions() {
		const ctaSection = document.querySelector('.team-cta-section');
		if (!ctaSection) return;
		
		const circles = [
			{ element: document.getElementById('domain-circle'), text: document.getElementById('domain-text') },
			{ element: document.getElementById('investment-circle'), text: document.getElementById('investment-text') },
			{ element: document.getElementById('relationships-circle'), text: document.getElementById('relationships-text') },
			{ element: document.getElementById('stanford-circle'), text: document.getElementById('stanford-text') }
		];
		
		let isLocked = false;
		let currentDescriptionIndex = -1;
		let scrollResistance = 0;
		let accumulatedDelta = 0; // Track actual scroll distance
		let lockScrollPosition = 0;
		let hasUserScrolled = false; // Track if user has actually scrolled
		let pageLoadTime = Date.now(); // Track when page loaded
		const SCROLL_RESISTANCE_THRESHOLD = 25; // Back to original sensitivity
		const DELTA_THRESHOLD = 150; // Much lower threshold for better UX
		
		// Ensure page starts at top on load/refresh
		window.scrollTo(0, 0);
		
		// Lock scroll by preventing all scroll events - NO body positioning
		function lockScroll() {
			if (isLocked) return;
			
			// Just store current position - don't change body styles
			lockScrollPosition = window.pageYOffset;
			
			isLocked = true;
			currentDescriptionIndex = -1;
			scrollResistance = 0;
			accumulatedDelta = 0;
			resetAllDescriptions();
			
			console.log('Scroll locked at position:', lockScrollPosition);
		}
		
		// Unlock scroll by simply allowing events again - NO repositioning
		function unlockScroll() {
			if (!isLocked) return;
			
			// Simply unlock - no body style changes, no repositioning
			isLocked = false;
			currentDescriptionIndex = -1;
			scrollResistance = 0;
			accumulatedDelta = 0;
			resetAllDescriptions();
			
			console.log('Scroll unlocked - continuing naturally with no repositioning');
		}
		
		function resetAllDescriptions() {
			circles.forEach((circle) => {
				if (circle.element && circle.text) {
					circle.element.style.opacity = '0.7';
					circle.element.style.strokeWidth = '1';
					circle.text.classList.remove('active');
				}
			});
		}
		
		function showDescription(index) {
			if (index < 0 || index >= circles.length) {
				resetAllDescriptions();
				return;
			}
			
			resetAllDescriptions();
			
			const activeCircle = circles[index];
			if (activeCircle.element && activeCircle.text) {
				activeCircle.element.style.opacity = '1';
				activeCircle.element.style.strokeWidth = '3';
				activeCircle.text.classList.add('active');
			}
			
			currentDescriptionIndex = index;
			console.log(`Showing description ${index + 1} of ${circles.length}`);
		}
		
		// Use Intersection Observer to detect when CTA section enters viewport
		const observerOptions = {
			root: null,
			rootMargin: '0px',
			threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] // More granular thresholds
		};
		
		let hasEnteredFromTop = false;
		let hasEnteredFromBottom = false;
		let lastScrollTop = window.pageYOffset;
		
		// Function to check if bottom of CTA section is at bottom of viewport
		function shouldLockAtBottom() {
			const ctaRect = ctaSection.getBoundingClientRect();
			const ctaBottom = ctaRect.bottom;
			const viewportHeight = window.innerHeight;
			
			// EXACT positioning - bottom of CTA aligned with bottom of viewport (small tolerance for precision)
			return Math.abs(ctaBottom - viewportHeight) <= 20;
		}
		
		const observer = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				const currentScrollTop = window.pageYOffset;
				const scrollingDown = currentScrollTop > lastScrollTop;
				const scrollingUp = currentScrollTop < lastScrollTop;
				lastScrollTop = currentScrollTop;
				
				// Mark that user has scrolled if they're not at the very top
				if (currentScrollTop > 10) {
					hasUserScrolled = true;
				}
				
				// Reduce time delay for faster response
				const timeSinceLoad = Date.now() - pageLoadTime;
				const canLock = hasUserScrolled && timeSinceLoad > 500;
				
				// Only use EXACT positioning - no fast scroll detection
				if (entry.isIntersecting && canLock) {
					if (scrollingDown && !hasEnteredFromTop && !isLocked) {
						// ONLY check precise bottom alignment
						if (shouldLockAtBottom()) {
							hasEnteredFromTop = true;
							hasEnteredFromBottom = false;
							lockScroll();
						}
					} else if (scrollingUp && !hasEnteredFromBottom && !isLocked) {
						// User scrolled up into section - lock immediately
						hasEnteredFromBottom = true;
						hasEnteredFromTop = false;
						lockScroll();
					}
				}
				
				// Section is completely out of view - reset flags
				if (!entry.isIntersecting && entry.intersectionRatio === 0) {
					if (scrollingDown) {
						// Section scrolled out from top
						hasEnteredFromTop = false;
					} else if (scrollingUp) {
						// Section scrolled out from bottom
						hasEnteredFromBottom = false;
					}
				}
			});
		}, observerOptions);
		
		observer.observe(ctaSection);
		
		// Create precise bottom-alignment observer using rootMargin technique
		// This is the proper way to detect when bottom of element reaches bottom of viewport
		const bottomAlignObserver = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				const timeSinceLoad = Date.now() - pageLoadTime;
				const canLock = hasUserScrolled && timeSinceLoad > 500;
				
				// When the element exits the viewport due to negative rootMargin,
				// it means the bottom of the element has reached the bottom of the viewport
				if (!entry.isIntersecting && !isLocked && canLock) {
					hasEnteredFromTop = true;
					hasEnteredFromBottom = false;
					lockScroll();
					console.log('Locked: Bottom of CTA aligned with bottom of viewport');
				}
			});
		}, {
			root: null, // Use viewport as root
			rootMargin: '0px 0px -100% 0px', // Negative bottom margin creates precise trigger
			threshold: 0
		});
		
		bottomAlignObserver.observe(ctaSection);
		
		// Track user scroll to enable locking
		function trackUserScroll() {
			if (window.pageYOffset > 10) {
				hasUserScrolled = true;
			}
		}
		
		window.addEventListener('scroll', trackUserScroll, { passive: true });
		
		// Prevent ALL scrolling when locked - this is the key to preventing jumps
		function preventScrollWhenLocked(e) {
			if (isLocked) {
				e.preventDefault();
				e.stopPropagation();
				// DO NOT use window.scrollTo - this causes bouncing
				return false;
			}
		}
		
		// Add comprehensive scroll prevention
		window.addEventListener('scroll', preventScrollWhenLocked, { passive: false });
		window.addEventListener('touchmove', preventScrollWhenLocked, { passive: false });
		
		// Handle wheel events when locked
		function handleWheel(e) {
			if (!isLocked) return;
			
			e.preventDefault();
			e.stopPropagation();
			
			if (e.deltaY > 0) {
				// Scrolling down
				scrollResistance++;
				accumulatedDelta += Math.abs(e.deltaY);
				console.log(`Scroll down resistance: ${scrollResistance}/${SCROLL_RESISTANCE_THRESHOLD}, delta: ${accumulatedDelta}/${DELTA_THRESHOLD}`);
				
				// Require BOTH sufficient events AND sufficient scroll distance
				if (scrollResistance >= SCROLL_RESISTANCE_THRESHOLD && accumulatedDelta >= DELTA_THRESHOLD) {
					const nextIndex = currentDescriptionIndex + 1;
					
					if (nextIndex < circles.length) {
						showDescription(nextIndex);
						scrollResistance = 0;
						accumulatedDelta = 0;
						console.log(`Advanced to description ${nextIndex + 1}`);
					} else {
						// All descriptions shown - simply unlock and let user continue naturally
						unlockScroll();
						console.log('All descriptions shown - unlocked for continued scrolling');
					}
				}
			} else if (e.deltaY < 0) {
				// Scrolling up
				scrollResistance++;
				accumulatedDelta += Math.abs(e.deltaY);
				console.log(`Scroll up resistance: ${scrollResistance}/${SCROLL_RESISTANCE_THRESHOLD}, delta: ${accumulatedDelta}/${DELTA_THRESHOLD}`);
				
				// Require BOTH sufficient events AND sufficient scroll distance
				if (scrollResistance >= SCROLL_RESISTANCE_THRESHOLD && accumulatedDelta >= DELTA_THRESHOLD) {
					const prevIndex = currentDescriptionIndex - 1;
					
					if (prevIndex >= -1) {
						showDescription(prevIndex); // -1 will reset all descriptions
						scrollResistance = 0;
						accumulatedDelta = 0;
						console.log(`Reversed to description ${prevIndex >= 0 ? prevIndex + 1 : 'none'}`);
						
						// If we've gone back past the first description, unlock upward
						if (prevIndex < 0) {
							unlockScroll();
							console.log('Reversed past first description - unlocked for upward scroll');
						}
					}
				}
			}
		}
		
		// Handle touch events for mobile
		let touchStartY = 0;
		let touchMoveCount = 0;
		let touchAccumulatedDelta = 0;
		let lastTouchDirection = 0; // 1 for down, -1 for up
		
		function handleTouchStart(e) {
			if (!isLocked) return;
			touchStartY = e.touches[0].clientY;
			touchMoveCount = 0;
			touchAccumulatedDelta = 0;
			lastTouchDirection = 0;
		}
		
		function handleTouchMove(e) {
			if (!isLocked) return;
			
			e.preventDefault();
			e.stopPropagation();
			
			const touchY = e.touches[0].clientY;
			const deltaY = touchStartY - touchY;
			
			// Only process significant movements
			if (Math.abs(deltaY) > 30) {
				const currentDirection = deltaY > 0 ? 1 : -1; // 1 for down, -1 for up
				
				// Reset count if direction changed
				if (lastTouchDirection !== 0 && lastTouchDirection !== currentDirection) {
					touchMoveCount = 0;
					touchAccumulatedDelta = 0;
				}
				
				lastTouchDirection = currentDirection;
				touchMoveCount++;
				touchAccumulatedDelta += Math.abs(deltaY);
				
				console.log(`Touch ${currentDirection > 0 ? 'down' : 'up'} resistance: ${touchMoveCount}/${SCROLL_RESISTANCE_THRESHOLD}, delta: ${touchAccumulatedDelta}/${DELTA_THRESHOLD}`);
				
				// Require BOTH sufficient touch events AND sufficient movement distance
				if (touchMoveCount >= SCROLL_RESISTANCE_THRESHOLD && touchAccumulatedDelta >= DELTA_THRESHOLD) {
					if (currentDirection > 0) {
						// Downward swipe
						const nextIndex = currentDescriptionIndex + 1;
						
						if (nextIndex < circles.length) {
							showDescription(nextIndex);
							touchMoveCount = 0;
							touchAccumulatedDelta = 0;
							touchStartY = touchY;
							console.log(`Touch advanced to description ${nextIndex + 1}`);
						} else {
							// All descriptions shown - simply unlock and let user continue naturally
							unlockScroll();
							console.log('All descriptions shown - touch unlocked');
						}
					} else {
						// Upward swipe
						const prevIndex = currentDescriptionIndex - 1;
						
						if (prevIndex >= -1) {
							showDescription(prevIndex);
							touchMoveCount = 0;
							touchAccumulatedDelta = 0;
							touchStartY = touchY;
							console.log(`Touch reversed to description ${prevIndex >= 0 ? prevIndex + 1 : 'none'}`);
							
							if (prevIndex < 0) {
								unlockScroll();
								console.log('Touch reversed past first - unlocked upward');
							}
						}
					}
				}
			}
		}
		
		function handleTouchEnd(e) {
			touchMoveCount = 0;
			touchAccumulatedDelta = 0;
			lastTouchDirection = 0;
		}
		
		// Keyboard support (for accessibility)
		function handleKeyDown(e) {
			if (!isLocked) return;
			
			if (e.key === 'ArrowDown' || e.key === 'PageDown') {
				e.preventDefault();
				const nextIndex = currentDescriptionIndex + 1;
				if (nextIndex < circles.length) {
					showDescription(nextIndex);
				} else {
					unlockScroll();
				}
			} else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
				e.preventDefault();
				const prevIndex = currentDescriptionIndex - 1;
				if (prevIndex >= -1) {
					showDescription(prevIndex);
					if (prevIndex < 0) {
						unlockScroll();
					}
				}
			} else if (e.key === 'Escape') {
				e.preventDefault();
				unlockScroll();
			}
		}
		
		// Add event listeners
		window.addEventListener('wheel', handleWheel, { passive: false });
		window.addEventListener('touchstart', handleTouchStart, { passive: false });
		window.addEventListener('touchmove', handleTouchMove, { passive: false });
		window.addEventListener('touchend', handleTouchEnd, { passive: false });
		window.addEventListener('keydown', handleKeyDown, { passive: false });
		
		// Cleanup function (for development)
		window.cleanupVennScrollInteractions = () => {
			observer.disconnect();
			bottomAlignObserver.disconnect();
			window.removeEventListener('scroll', trackUserScroll);
			window.removeEventListener('scroll', preventScrollWhenLocked);
			window.removeEventListener('touchmove', preventScrollWhenLocked);
			window.removeEventListener('wheel', handleWheel);
			window.removeEventListener('touchstart', handleTouchStart);
			window.removeEventListener('touchmove', handleTouchMove);
			window.removeEventListener('touchend', handleTouchEnd);
			window.removeEventListener('keydown', handleKeyDown);
			if (isLocked) {
				unlockScroll();
			}
		};
	}
</script>

<style>
	.main {
		margin: 0;
		padding: 0;
	}
	
	.hero {
		position: relative;
		height: calc(100vh - 80px); /* Use height instead of min-height for exact sizing */
		overflow: hidden;
		margin: 0;
		padding: 0;
	}
	
	.tesseract-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 1;
		pointer-events: none;
	}
	
	#tesseract-canvas {
		width: 100%;
		height: 100%;
		display: block;
	}
	
	.hero-container {
		width: 100%;
		max-width: 1200px;
		margin: 0 auto;
		padding: 0 var(--spacing-lg);
		position: relative;
		z-index: 10;
		height: 100%; /* Add this so percentage-based positioning works */
	}
	
	.hero-content {
		max-width: 800px;
		margin-left: 16.5%;
		margin-top: 29vh;
		position: relative;
	}
	
	.hero-title {
		font-size: 3rem;
		font-weight: 700;
		line-height: 1.1;
		margin-bottom: var(--spacing-xl);
		color: var(--text-primary);
	}
	
	.hero-subtitle {
		font-size: 1.3rem;
		line-height: 1.6;
		color: var(--text-secondary);
		margin: 0;
	}
	
	/* Mobile devices - optimized layout */
	@media (max-width: 768px) {
		.hero {
			height: calc(100vh - 80px);
			padding: 0;
			display: flex;
			align-items: center;
		}
		
		.hero-container {
			padding: 0 var(--spacing-md);
			width: 100%;
		}
		
		.hero-content {
			max-width: 90%;
			margin-left: 5%;
			margin-top: 20vh;
			text-align: left;
			padding: 0;
		}
		
		.hero-title {
			font-size: 2rem;
			line-height: 1.2;
			margin-bottom: var(--spacing-lg);
		}
		
		.hero-subtitle {
			font-size: 1.1rem;
			line-height: 1.5;
		}
		
		/* Keep animation but optimize for mobile performance */
		.tesseract-container {
			display: block;
		}
		
		.main {
			background: var(--bg-white);
		}
	}
	
	/* Small phones */
	@media (max-width: 480px) {
		.hero {
			padding: var(--spacing-lg) 0;
		}
		
		.hero-title {
			font-size: 1.6rem;
			margin-bottom: var(--spacing-md);
		}
		
		.hero-subtitle {
			font-size: 1rem;
			line-height: 1.4;
		}
		
		.hero-container {
			padding: 0 var(--spacing-sm);
		}
		
		.hero-content {
			max-width: 95%;
			margin-left: 2.5%;
			padding: 0;
		}
	}
	
	/* Team CTA Section */
	.team-cta-section {
		background: #000000; /* Pure black */
		color: #ffffff; /* Pure white text */
		padding: var(--spacing-lg) 0; /* Much smaller padding */
	}
	
	.team-cta-container {
		max-width: 1200px;
		margin: 0 auto;
		padding: var(--spacing-3xl) var(--spacing-lg); /* Even more vertical padding */
		text-align: center;
	}
	
	.team-cta-content {
		max-width: 800px;
		margin: 0 auto;
	}
	
	.team-cta-text {
		font-size: 1.3rem; /* Match hero subtitle font size */
		line-height: 1.6; /* Match hero subtitle line height */
		margin: 0 0 var(--spacing-xl) 0;
		font-weight: 400;
		color: inherit; /* Use inherited color from section */
	}
	
	.team-cta-button {
		display: inline-flex;
		align-items: center;
		padding: 8px 20px; /* Match filter button padding */
		background: transparent; /* Transparent background like filter buttons */
		color: #ffffff; /* White text on black background */
		text-decoration: none;
		border-radius: 25px; /* Match filter button border radius */
		font-weight: 500; /* Match filter button font weight */
		font-size: 14px; /* Match filter button font size */
		transition: all 0.2s ease;
		border: 1px solid #ffffff; /* White border on black background */
	}
	
	.team-cta-button:hover {
		background: #ffffff; /* White background on hover */
		color: #000000; /* Black text on hover */
		border-color: #ffffff;
	}
	
	/* Mobile styles for team CTA */
	@media (max-width: 768px) {
		.team-cta-section {
			padding: var(--spacing-2xl) 0;
		}
		
		.team-cta-container {
			padding: 0 var(--spacing-md);
		}
		
		.team-cta-text {
			font-size: 1.1rem; /* Match mobile hero subtitle font size */
			line-height: 1.5; /* Match mobile hero subtitle line height */
		}
		
		.team-cta-button {
			padding: 14px var(--spacing-lg);
			font-size: 0.9rem;
		}
		
		.venn-diagram {
			margin-top: var(--spacing-lg);
			max-width: 420px; /* Back to original mobile size */
			margin-left: 0; /* Keep left aligned on mobile */
		}
		
		.venn-content {
			flex-direction: column;
			gap: var(--spacing-md);
		}
		
		.venn-visual, .venn-text {
			flex: none;
			width: 100%;
		}
		
		.venn-description {
			padding: var(--spacing-sm);
		}
		
		.venn-description p {
			font-size: 0.85rem;
		}
		
		.venn-label {
			font-size: 12px; /* Proportionally smaller for mobile, but same for all labels */
		}
		
		.venn-center-label {
			font-size: 12px; /* Same as other labels on mobile */
		}
	}
	
	@media (max-width: 480px) {
		.team-cta-container {
			padding: 0 var(--spacing-sm);
		}
		
		.team-cta-text {
			font-size: 1.1rem;
		}
		
		.venn-diagram {
			max-width: 350px; /* Back to original small phone size */
			margin-left: 0; /* Keep left aligned */
		}
		
		.venn-description {
			padding: var(--spacing-xs);
		}
		
		.venn-description p {
			font-size: 0.8rem;
			line-height: 1.4;
		}
		
		.venn-label {
			font-size: 11px; /* Proportionally larger for small phones */
		}
		
		.venn-center-label {
			font-size: 10px; /* Small center text on small phones */
		}
	}

	/* Venn Diagram Styles */
	.venn-diagram {
		margin-top: var(--spacing-sm);
		width: fit-content; /* Exactly the width of content */
		margin-left: 0;
		margin-right: auto;
		display: block;
	}

	.venn-content {
		display: flex;
		align-items: flex-start;
		gap: 5px;
		width: fit-content; /* No excess width */
	}

	.venn-visual {
		flex: 0 0 360px; /* Much smaller diagram - reduced from 560px */
		position: relative;
	}

	.venn-text {
		flex: 0 0 480px; /* Much smaller fixed width */
		position: relative;
		min-height: 200px;
	}

	.venn-description {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		background: rgba(0, 0, 0, 0.8);
		padding: var(--spacing-2xl);
		border-radius: 12px;
		box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
		transition: opacity 0.5s ease-in-out;
		opacity: 0;
		backdrop-filter: blur(8px);
		text-align: left;
	}

	.venn-description.active {
		opacity: 1;
	}

	.venn-description p {
		font-size: 1.2rem;
		line-height: 1.7;
		color: #ffffff;
		margin: 0;
	}

	.venn-svg {
		width: 100%;
		height: auto;
	}

	.venn-circle {
		fill: none; /* Transparent fill */
		stroke: #ffffff; /* White border on black background */
		stroke-width: 1; /* Match button border width */
		opacity: 0.7;
		transition: opacity 0.3s ease;
	}

	.venn-circle:hover {
		opacity: 1;
	}

	.venn-label {
		font-size: 15px; /* Same size as center label */
		font-weight: 600;
		fill: #ffffff; /* White text on black background */
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
	}

	.venn-center {
		fill: #ffffff; /* White fill for center circle */
		stroke: #ffffff; /* White border */
		stroke-width: 1; /* Match button and outer circles */
		opacity: 1; /* Fully opaque */
	}

	.venn-center-label {
		font-size: 15px; /* Same as other labels */
		font-weight: 600; /* Same weight as other labels */
		fill: #000000; /* Black text on white center circle */
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
	}
</style>
