---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
---

<Layout title="Home" description="Deep technology innovation and investing.">
	<Header currentPath="/" />
	
	<main class="main">
		<section class="hero">
			<div class="tesseract-container">
				<canvas id="tesseract-canvas"></canvas>
			</div>
			<div class="hero-container">
				<div class="hero-content">
					<h1 class="hero-title">We're betting on deep technology innovation and adoption from the birthplace of Silicon Valley.</h1>
					<p class="hero-subtitle">Novana's Stanford-based team produces in-house technology analyses, investment research briefs, and market trend writeups across edge computing, biotechnology, artificial intelligence, and other frontier technology industries.</p>
				</div>
			</div>
		</section>
	</main>
	<Footer />
</Layout>

<script>
	class FlowingPointCloud {
		constructor() {
			this.canvas = document.getElementById('tesseract-canvas');
			this.ctx = this.canvas.getContext('2d');
			
			// Full page canvas
			this.resizeCanvas();
			
			// Generate flowing point cloud
			this.pointCloud = this.generateFlowingPoints();
			
			// Animation parameters
			this.time = 0;
			this.waveSpeed = 0.007; // Increased from 0.005
			
			// Performance monitoring
			this.frameCount = 0;
			this.lastTime = performance.now();
			
			this.setupCanvas();
			this.animate();
			
			// Handle window resize
			window.addEventListener('resize', () => this.resizeCanvas());
			
			// Listen for theme changes
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
						// Theme changed, canvas will update on next frame
					}
				});
			});
			observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
		}
		
		resizeCanvas() {
			const devicePixelRatio = window.devicePixelRatio || 1;
			
			// Get hero section dimensions instead of window dimensions
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Set logical size to hero dimensions
			this.canvas.style.width = heroWidth + 'px';
			this.canvas.style.height = heroHeight + 'px';
			
			// Set actual canvas size accounting for device pixel ratio
			this.canvas.width = heroWidth * devicePixelRatio;
			this.canvas.height = heroHeight * devicePixelRatio;
			
			// Scale the context to match device pixel ratio
			this.ctx.scale(devicePixelRatio, devicePixelRatio);
			
			console.log(`Canvas: ${heroWidth}x${heroHeight} logical, ${this.canvas.width}x${this.canvas.height} physical, DPR: ${devicePixelRatio}`);
			
			// Regenerate points when window size changes significantly for consistent coverage
			const newArea = heroWidth * heroHeight; // Use hero dimensions for area calculation
			const oldArea = this.lastArea || newArea;
			const areaChange = Math.abs(newArea - oldArea) / oldArea;
			
			if (areaChange > 0.2) { // Regenerate if area changed by more than 20%
				console.log('Significant size change detected, regenerating points for consistent coverage...');
				this.pointCloud = this.generateFlowingPoints();
				this.lastArea = newArea;
			}
		}
		
		setupCanvas() {
			this.ctx.imageSmoothingEnabled = true;
			this.ctx.imageSmoothingQuality = 'high';
		}
		
		// Generate flowing, organic point cloud
		generateFlowingPoints() {
			const points = [];
			
			// Get hero section dimensions
			const heroSection = document.querySelector('.hero');
			const screenWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const screenHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Calculate spacing based on hero section size to maintain visual density
			const screenDiagonal = Math.sqrt(screenWidth*screenWidth + screenHeight*screenHeight);
			const referenceDiagonal = Math.sqrt(1920*1920 + 1080*1080); // Reference: 1920x1080
			const scaleFactor = screenDiagonal / referenceDiagonal;
			
			// Detect mobile device for performance optimization
			const isMobile = window.innerWidth <= 768;
			const mobileReduction = isMobile ? 0.5 : 1.0; // Reduce density by 50% on mobile
			
			// Reduced density for better performance - larger spacing
			const baseGridSize = 80 * mobileReduction; // Further reduced on mobile
			const gridSize = Math.floor(baseGridSize * scaleFactor);
			const baseSpacing = (1.0 / mobileReduction); // Increased spacing on mobile
			const mainSpacing = baseSpacing * scaleFactor;
			const secondarySpacing = mainSpacing * 1.8; // Increased from 1.5
			
			console.log(`Hero: ${screenWidth}x${screenHeight} logical, Scale factor: ${scaleFactor.toFixed(2)}, Mobile: ${isMobile}, Grid: ${gridSize}, Spacing: ${mainSpacing.toFixed(2)}`);
			
			// Create wave surfaces - reduced density for better performance
			const waveAmplitude = 2.0;
			
			// Main wave surface - reduced density for performance
			for (let x = -gridSize; x <= gridSize; x += mainSpacing) {
				for (let y = -gridSize; y <= gridSize; y += mainSpacing) {
					// Create wave height based on position
					const distance = Math.sqrt(x*x + y*y);
					const baseZ = Math.sin(distance * 0.15) * waveAmplitude * Math.exp(-distance * 0.015);
					
					// Add multiple wave components for richer pattern
					const wave1 = Math.sin(x * 0.1) * 0.6;
					const wave2 = Math.cos(y * 0.08) * 0.5;
					const wave3 = Math.sin((x + y) * 0.05) * 0.4;
					const wave4 = Math.cos((x - y) * 0.06) * 0.3;
					const wave5 = Math.sin(x * 0.12 + y * 0.07) * 0.35;
					const wave6 = Math.cos(distance * 0.08) * 0.25;
					
					const z = baseZ + wave1 + wave2 + wave3 + wave4 + wave5 + wave6;
					
					points.push({
						baseX: x * 0.12,
						baseY: y * 0.12,
						baseZ: z,
						gridX: x,
						gridY: y,
						amplitude: 0.8
					});
				}
			}
			
			// Add secondary wave surface - reduced density for performance
			for (let x = -gridSize; x <= gridSize; x += secondarySpacing) {
				for (let y = -gridSize; y <= gridSize; y += secondarySpacing) {
					const distance = Math.sqrt(x*x + y*y);
					const baseZ = Math.cos(distance * 0.12 + Math.PI/4) * waveAmplitude * 0.8 * Math.exp(-distance * 0.012);
					
					// Additional wave components for secondary surface
					const wave1 = Math.cos(x * 0.09) * 0.5;
					const wave2 = Math.sin(y * 0.06) * 0.4;
					const wave3 = Math.sin((x * 2 + y) * 0.04) * 0.3;
					const wave4 = Math.cos((x + y * 2) * 0.05) * 0.25;
					
					const z = baseZ + wave1 + wave2 + wave3 + wave4 + 1.2;
					
					points.push({
						baseX: x * 0.12,
						baseY: y * 0.12,
						baseZ: z,
						gridX: x,
						gridY: y,
						amplitude: 0.6,
						isSecondary: true
					});
				}
			}
			
			// Add wave disturbances - reduced count for performance, especially on mobile
			const disturbanceCount = Math.floor(6 * Math.min(scaleFactor, 1.0) * mobileReduction); // Reduced on mobile
			const disturbanceSpacing = secondarySpacing * 1.5; // Increased spacing
			
			for (let i = 0; i < disturbanceCount; i++) {
				const centerX = (Math.random() - 0.5) * gridSize * 1.5;
				const centerY = (Math.random() - 0.5) * gridSize * 1.5;
				const radius = (20 + Math.random() * 15) * scaleFactor; // Slightly smaller radius
				
				for (let x = centerX - radius; x <= centerX + radius; x += disturbanceSpacing) {
					for (let y = centerY - radius; y <= centerY + radius; y += disturbanceSpacing) {
						const dist = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
						if (dist <= radius) {
							const ripple = Math.cos(dist * 0.3) * (1 - dist/radius) * 1.0;
							
							points.push({
								baseX: x * 0.12,
								baseY: y * 0.12,
								baseZ: ripple,
								gridX: x,
								gridY: y,
								amplitude: 0.5,
								disturbance: i
							});
						}
					}
				}
			}
			
			console.log(`Generated ${points.length} wave surface points (optimized for performance${isMobile ? ', mobile' : ''})`);
			return points;
		}
		
		// Project 3D to 2D screen coordinates
		project3DTo2D(x, y, z) {
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			const scale = Math.min(heroWidth, heroHeight) * 0.15; // Use hero dimensions
			const centerX = heroWidth / 2; // Use hero dimensions
			const centerY = heroHeight / 2;
			
			// Perspective projection - no rotation to prevent gaps
			const distance = 8;
			const projectedScale = scale / (1 + z / distance);
			
			return [
				centerX + x * projectedScale,
				centerY - y * projectedScale,
				z
			];
		}
		
		// Draw point with wave surface appearance - enhanced shadows and contrast
		drawPoint(x, y, z, intensity = 1, pointType = 'normal') {
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// More aggressive culling for performance
			if (x < -10 || x >= heroWidth + 10 || y < -10 || y >= heroHeight + 10) return; // Use hero dimensions
			
			// Simplified point size calculation
			let baseSize = 0.7; // Slightly smaller for performance
			if (pointType === 'secondary') baseSize = 0.5;
			if (pointType === 'disturbance') baseSize = 0.6;
			
			const depthSize = Math.max(0.2, baseSize + (5 - z) * 0.08);
			
			// Enhanced shadow calculation for dramatic fold contrast
			const baseIntensity = intensity * 0.85; // Slightly reduced base for more shadow range
			
			// More dramatic depth-based shadows - deeper valleys get much darker
			const depthFactor = Math.max(0.15, Math.min(1.0, 0.9 - z / 8)); // Increased depth sensitivity
			
			// Secondary shadow based on wave position for fold enhancement
			const foldShadow = Math.max(0.6, 1.0 - Math.abs(z) * 0.3); // Deeper folds get darker
			
			const finalIntensity = baseIntensity * depthFactor * foldShadow;
			
			// Theme-aware point colors
			const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
			let darkness;
			
			if (isDark) {
				// In dark mode, use light colors (inverse of light mode)
				darkness = Math.floor(finalIntensity * 200) + 55; // Range: 55 to 255 (light colors)
			} else {
				// In light mode, use dark colors
				darkness = Math.floor((1 - finalIntensity) * 250) + 5; // Range: 5 to 255 (dark colors)
			}
			
			this.ctx.fillStyle = `rgb(${darkness}, ${darkness}, ${darkness})`;
			this.ctx.globalAlpha = 0.6;
			
			// Draw point - no stroke for performance
			this.ctx.beginPath();
			this.ctx.arc(x, y, depthSize, 0, Math.PI * 2);
			this.ctx.fill();
		}
		
		update() {
			// Performance monitoring
			this.frameCount++;
			const currentTime = performance.now();
			if (currentTime - this.lastTime >= 1000) {
				console.log(`FPS: ${this.frameCount}, Points: ${this.pointCloud.length}`);
				this.frameCount = 0;
				this.lastTime = currentTime;
			}
			
			// Get hero section dimensions
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Clear canvas with theme-aware background
			const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
			this.ctx.fillStyle = isDark ? '#0f0f0f' : '#ffffff';
			this.ctx.fillRect(0, 0, heroWidth, heroHeight); // Use hero dimensions
			
			// Apply wave motion to all points - NO ROTATION
			const wavePoints = this.pointCloud.map(point => {
				// Create traveling wave motion with more wave components
				const wavePhase = this.time * 3;
				
				// Multiple wave components for richer motion
				const wave1 = Math.sin(point.gridX * 0.3 + wavePhase) * 0.3;
				const wave2 = Math.cos(point.gridY * 0.25 + wavePhase * 0.8) * 0.25;
				const wave3 = Math.sin((point.gridX + point.gridY) * 0.2 + wavePhase * 1.2) * 0.2;
				const wave4 = Math.cos((point.gridX - point.gridY) * 0.15 + wavePhase * 0.6) * 0.15;
				const wave5 = Math.sin(point.gridX * 0.35 + point.gridY * 0.18 + wavePhase * 1.5) * 0.18;
				const wave6 = Math.cos(point.gridY * 0.28 - point.gridX * 0.12 + wavePhase * 0.9) * 0.12;
				const wave7 = Math.sin((point.gridX * 2 + point.gridY) * 0.08 + wavePhase * 2.0) * 0.1;
				
				// Combine base position with enhanced wave motion
				const flowX = point.baseX;
				const flowY = point.baseY;
				const flowZ = point.baseZ + wave1 + wave2 + wave3 + wave4 + wave5 + wave6 + wave7;
				
				let pointType = 'normal';
				if (point.isSecondary) pointType = 'secondary';
				if (point.disturbance !== undefined) pointType = 'disturbance';
				
				return {
					x: flowX,
					y: flowY,
					z: flowZ,
					pointType: pointType
				};
			});
			
			// Project to 2D with aggressive culling for performance
			const projectedPoints = wavePoints.map(point => {
				const [x, y, z] = this.project3DTo2D(point.x, point.y, point.z);
				return {
					x, y, z,
					pointType: point.pointType
				};
			}).filter(point => {
				// Very aggressive culling for performance
				return point.x > -30 && point.x < heroWidth + 30 && 
				       point.y > -30 && point.y < heroHeight + 30;
			}).sort((a, b) => a.z - b.z);
			
			// Draw all points with simplified intensity calculation
			for (const point of projectedPoints) {
				// Simplified pulse calculation for performance
				const pulse = 0.7 + Math.sin(this.time * 2 + point.x * 0.005 + point.y * 0.005) * 0.3;
				
				this.drawPoint(point.x, point.y, point.z, pulse, point.pointType);
			}
			
			// Reset alpha
			this.ctx.globalAlpha = 1;
			
			// Update time
			this.time += this.waveSpeed;
		}
		
		animate() {
			this.update();
			requestAnimationFrame(() => this.animate());
		}
	}
	
	// Initialize when page loads
	document.addEventListener('DOMContentLoaded', () => {
		new FlowingPointCloud();
	});
</script>

<style>
	.main {
		margin: 0;
		padding: 0;
	}
	
	.hero {
		position: relative;
		height: calc(100vh - 80px); /* Use height instead of min-height for exact sizing */
		overflow: hidden;
		margin: 0;
		padding: 0;
	}
	
	.tesseract-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 1;
		pointer-events: none;
	}
	
	#tesseract-canvas {
		width: 100%;
		height: 100%;
		display: block;
	}
	
	.hero-container {
		width: 100%;
		max-width: 1200px;
		margin: 0 auto;
		padding: 0 var(--spacing-lg);
		position: relative;
		z-index: 10;
		height: 100%; /* Add this so percentage-based positioning works */
	}
	
	.hero-content {
		max-width: 800px;
		margin-left: 16.5%;
		margin-top: 29vh; /* Use margin-top instead of absolute positioning - adjust this value to move text up/down */
		position: relative; /* Change from absolute to relative */
	}
	
	.hero-title {
		font-size: 3rem;
		font-weight: 700;
		line-height: 1.1;
		margin-bottom: var(--spacing-xl);
		color: var(--text-primary);
	}
	
	.hero-subtitle {
		font-size: 1.3rem;
		line-height: 1.6;
		color: var(--text-secondary);
		margin: 0;
	}
	
	/* Mobile devices - completely different layout */
	@media (max-width: 768px) {
		.hero {
			height: auto; /* Allow natural height on mobile */
			min-height: 100vh; /* Ensure full screen coverage */
			padding: var(--spacing-xl) 0;
		}
		
		.hero-container {
			padding: 0 var(--spacing-md); /* Reduce side padding */
		}
		
		.hero-content {
			max-width: 100%; /* Use full width */
			margin-left: 0; /* Remove left margin */
			margin-top: var(--spacing-2xl); /* Reduce top margin */
			text-align: left; /* Left align instead of center */
		}
		
		.hero-title {
			font-size: 2.2rem; /* Slightly larger than before */
			line-height: 1.2;
			margin-bottom: var(--spacing-lg);
		}
		
		.hero-subtitle {
			font-size: 1.1rem; /* Slightly larger than before */
			line-height: 1.5;
		}
		
		/* Keep animation on mobile but reduce density for performance */
		.tesseract-container {
			display: block; /* Show animation on mobile */
		}
		
		.main {
			background: var(--bg-white); /* Ensure proper background */
		}
	}
	
	/* Small phones */
	@media (max-width: 480px) {
		.hero-title {
			font-size: 1.8rem;
		}
		
		.hero-subtitle {
			font-size: 1rem;
		}
		
		.hero-container {
			padding: 0 var(--spacing-sm);
		}
	}
</style>