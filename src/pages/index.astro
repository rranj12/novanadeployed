---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import ArticleCard from '../components/ArticleCard.astro';

// Latest 3 articles for the homepage
const latestArticles = [
	{
		slug: 'factor-investing-biotech-equities',
		title: 'On Factor Investing for U.S. Biotechnology Equities',
		excerpt: 'We backtest three factor investing-frameworks for U.S. biotech equities against a 15 year period, finding that none produced statistically significant alpha.',
		tags: ['Research', 'Factor Investing', 'Biotechnology'],
		authors: 'Justin Wang, Rishabh Ranjan',
		date: 'June 13, 2025',
		readingTime: '10 min read',
		category: 'research'
	},
	{
		slug: 'data-center-growth',
		title: 'Our Thoughts on Data Center Growth',
		excerpt: 'Novana Research examines the data center: its role in the AI value chain, infrastructure context, and future expansion hotbeds.',
		tags: ['Research','Data Center', 'AI', 'Infrastructure'],
		authors: 'Justin Wang, Rishabh Ranjan',
		date: 'July 15, 2025',
		readingTime: '7 min read',
		category: 'research',
		image: '/ai-value-chain.png',
	},
	{
		slug: 'beyond-silicon-biological-computing',
		title: 'Beyond Silicon: Inside the Era of Biological Computing',
		excerpt: 'This piece is a part of Novana Scientific\'s "Concrete Foundations of Compute" series. Exploring the rise of biological (wetware) computing, its pioneers, and the future of hybrid AI hardware.',
		tags: ['Research', 'Biological Computing', 'Semiconductors', 'AI'],
		authors: 'Rishabh Ranjan, Justin Wang',
		date: 'July 14, 2028',
		readingTime: '7 min read',
		category: 'research'
	}
];
---

<Layout title="Home" description="Deep technology innovation and investing.">
	<Header currentPath="/" />
	
	<main class="main">
		<section class="hero">
			<div class="tesseract-container">
				<canvas id="tesseract-canvas"></canvas>
			</div>
			<div class="hero-container">
				<div class="hero-content">
					<h1 class="hero-title">We're betting on deep technology innovation and adoption from the birthplace of Silicon Valley.</h1>
					<p class="hero-subtitle">Novana's Stanford-based team produces in-house technology analyses, investment research briefs, and market trend writeups across edge computing, biotechnology, artificial intelligence, and other frontier technology industries.</p>
				</div>
			</div>
		</section>
	</main>
	
	<!-- Team Section -->
	<section class="team-cta-section">
		<div class="team-cta-container">
			<div class="team-cta-content">
				<p class="team-cta-text">We bring together scientific domain knowledge and end-to-end investment management expertise to produce empirically sound findings for those looking to invest in the future.</p>
				<a href="/about" class="team-cta-button">Meet the Team</a>
				
				<!-- Venn Diagram -->
				<div class="venn-diagram">
					<div class="venn-content">
						<div class="venn-visual">
							<svg viewBox="0 0 380 420" class="venn-svg">
								<!-- Top left circle -->
								<circle cx="110" cy="135" r="99" class="venn-circle" id="domain-circle" />
								<text x="105" y="125" class="venn-label">DOMAIN</text>
								<text x="105" y="140" class="venn-label">KNOWLEDGE</text>
								
								<!-- Top right circle -->
								<circle cx="280" cy="135" r="99" class="venn-circle" id="investment-circle" />
								<text x="285" y="125" class="venn-label">INVESTMENT</text>
								<text x="285" y="140" class="venn-label">EXPERTISE</text>
								
								<!-- Bottom left circle -->
								<circle cx="110" cy="305" r="99" class="venn-circle" id="stanford-circle" />
								<text x="105" y="305" class="venn-label">STANFORD-</text>
								<text x="105" y="320" class="venn-label">BASED</text>
								
								<!-- Bottom right circle -->
								<circle cx="280" cy="305" r="99" class="venn-circle" id="relationships-circle" />
								<text x="285" y="310" class="venn-label">RELATIONSHIPS</text>
								
								<!-- Center circle -->
								<circle cx="195" cy="210" r="60" class="venn-center" />
								<text x="195" y="212" class="venn-center-label">NOVANA</text>
							</svg>
						</div>
						
						<div class="venn-text">
							<div class="venn-description" id="domain-text">
								<p>We're researchers at heart, with competent domains spanning cancer metabolism, ultrasound drug uncaging, spatial omics, ophthalmology diagnostics, and artificial intelligence.</p>
							</div>
							
							<div class="venn-description" id="investment-text">
								<p>Our investment management framework is the result of past professional experiences in long-only fundamental equities, enterprise-grade systematic investment strategy design, and buy-side equities trading.</p>
							</div>
							
							<div class="venn-description" id="relationships-text">
								<p>We maintain deep, durable relationships across the Bay Area and East Coast, including those with scientific researchers, technical student-founders, venture investors, and asset management executives.</p>
							</div>
							
							<div class="venn-description" id="stanford-text">
								<p>We have unparalleled access to Stanford's research faculty, student founders, and startup ecosystem, allowing us to source scientific innovations well before they enter venture or public market pipelines.</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</section>
	
	<!-- Latest Research Section -->
	<section class="latest-research-section">
		<div class="container">
			<div class="latest-research-content">
				<h2 class="latest-research-title">Latest Research</h2>
				<a href="/research" class="latest-research-button">View All Research</a>
				
				<div class="articles-grid">
					{latestArticles.map(article => (
						<ArticleCard article={article} basePath={article.category === 'scientific' ? '/scientific' : '/articles'} />
					))}
				</div>
			</div>
		</div>
	</section>
	
	<Footer />
</Layout>

<script>
	class FlowingPointCloud {
		constructor() {
			this.canvas = document.getElementById('tesseract-canvas');
			this.ctx = this.canvas.getContext('2d');
			
			// Full page canvas
			this.resizeCanvas();
			
			// Generate flowing point cloud
			this.pointCloud = this.generateFlowingPoints();
			
			// Animation parameters
			this.time = 0;
			this.waveSpeed = 0.007; // Increased from 0.005
			
			// Performance monitoring
			this.frameCount = 0;
			this.lastTime = performance.now();
			
			this.setupCanvas();
			this.animate();
			
			// Handle window resize
			window.addEventListener('resize', () => this.resizeCanvas());
			
			// Listen for theme changes
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
						// Theme changed, canvas will update on next frame
					}
				});
			});
			observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });
		}
		
		resizeCanvas() {
			const devicePixelRatio = window.devicePixelRatio || 1;
			
			// Get hero section dimensions instead of window dimensions
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Set logical size to hero dimensions
			this.canvas.style.width = heroWidth + 'px';
			this.canvas.style.height = heroHeight + 'px';
			
			// Set actual canvas size accounting for device pixel ratio
			this.canvas.width = heroWidth * devicePixelRatio;
			this.canvas.height = heroHeight * devicePixelRatio;
			
			// Scale the context to match device pixel ratio
			this.ctx.scale(devicePixelRatio, devicePixelRatio);
			
			console.log(`Canvas: ${heroWidth}x${heroHeight} logical, ${this.canvas.width}x${this.canvas.height} physical, DPR: ${devicePixelRatio}`);
			
			// Regenerate points when window size changes significantly for consistent coverage
			const newArea = heroWidth * heroHeight; // Use hero dimensions for area calculation
			const oldArea = this.lastArea || newArea;
			const areaChange = Math.abs(newArea - oldArea) / oldArea;
			
			if (areaChange > 0.2) { // Regenerate if area changed by more than 20%
				console.log('Significant size change detected, regenerating points for consistent coverage...');
				this.pointCloud = this.generateFlowingPoints();
				this.lastArea = newArea;
			}
		}
		
		setupCanvas() {
			this.ctx.imageSmoothingEnabled = true;
			this.ctx.imageSmoothingQuality = 'high';
		}
		
		// Generate flowing, organic point cloud
		generateFlowingPoints() {
			const points = [];
			
			// Get hero section dimensions
			const heroSection = document.querySelector('.hero');
			const screenWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const screenHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Calculate spacing based on hero section size to maintain visual density
			const screenDiagonal = Math.sqrt(screenWidth*screenWidth + screenHeight*screenHeight);
			const referenceDiagonal = Math.sqrt(1920*1920 + 1080*1080); // Reference: 1920x1080
			const scaleFactor = screenDiagonal / referenceDiagonal;
			
			// Detect mobile device for performance optimization
			const isMobile = window.innerWidth <= 768;
			const mobileReduction = isMobile ? 0.5 : 1.0; // Reduce density by 50% on mobile
			
			// Reduced density for better performance - larger spacing
			const baseGridSize = 80 * mobileReduction; // Further reduced on mobile
			const gridSize = Math.floor(baseGridSize * scaleFactor);
			const baseSpacing = (1.0 / mobileReduction); // Increased spacing on mobile
			const mainSpacing = baseSpacing * scaleFactor;
			const secondarySpacing = mainSpacing * 1.8; // Increased from 1.5
			
			console.log(`Hero: ${screenWidth}x${screenHeight} logical, Scale factor: ${scaleFactor.toFixed(2)}, Mobile: ${isMobile}, Grid: ${gridSize}, Spacing: ${mainSpacing.toFixed(2)}`);
			
			// Create wave surfaces - reduced density for better performance
			const waveAmplitude = 2.0;
			
			// Main wave surface - reduced density for performance
			for (let x = -gridSize; x <= gridSize; x += mainSpacing) {
				for (let y = -gridSize; y <= gridSize; y += mainSpacing) {
					// Create wave height based on position
					const distance = Math.sqrt(x*x + y*y);
					const baseZ = Math.sin(distance * 0.15) * waveAmplitude * Math.exp(-distance * 0.015);
					
					// Add multiple wave components for richer pattern
					const wave1 = Math.sin(x * 0.1) * 0.6;
					const wave2 = Math.cos(y * 0.08) * 0.5;
					const wave3 = Math.sin((x + y) * 0.05) * 0.4;
					const wave4 = Math.cos((x - y) * 0.06) * 0.3;
					const wave5 = Math.sin(x * 0.12 + y * 0.07) * 0.35;
					const wave6 = Math.cos(distance * 0.08) * 0.25;
					
					const z = baseZ + wave1 + wave2 + wave3 + wave4 + wave5 + wave6;
					
					points.push({
						baseX: x * 0.12,
						baseY: y * 0.12,
						baseZ: z,
						gridX: x,
						gridY: y,
						amplitude: 0.8
					});
				}
			}
			
			// Add secondary wave surface - reduced density for performance
			for (let x = -gridSize; x <= gridSize; x += secondarySpacing) {
				for (let y = -gridSize; y <= gridSize; y += secondarySpacing) {
					const distance = Math.sqrt(x*x + y*y);
					const baseZ = Math.cos(distance * 0.12 + Math.PI/4) * waveAmplitude * 0.8 * Math.exp(-distance * 0.012);
					
					// Additional wave components for secondary surface
					const wave1 = Math.cos(x * 0.09) * 0.5;
					const wave2 = Math.sin(y * 0.06) * 0.4;
					const wave3 = Math.sin((x * 2 + y) * 0.04) * 0.3;
					const wave4 = Math.cos((x + y * 2) * 0.05) * 0.25;
					
					const z = baseZ + wave1 + wave2 + wave3 + wave4 + 1.2;
					
					points.push({
						baseX: x * 0.12,
						baseY: y * 0.12,
						baseZ: z,
						gridX: x,
						gridY: y,
						amplitude: 0.6,
						isSecondary: true
					});
				}
			}
			
			// Add wave disturbances - reduced count for performance, especially on mobile
			const disturbanceCount = Math.floor(6 * Math.min(scaleFactor, 1.0) * mobileReduction); // Reduced on mobile
			const disturbanceSpacing = secondarySpacing * 1.5; // Increased spacing
			
			for (let i = 0; i < disturbanceCount; i++) {
				const centerX = (Math.random() - 0.5) * gridSize * 1.5;
				const centerY = (Math.random() - 0.5) * gridSize * 1.5;
				const radius = (20 + Math.random() * 15) * scaleFactor; // Slightly smaller radius
				
				for (let x = centerX - radius; x <= centerX + radius; x += disturbanceSpacing) {
					for (let y = centerY - radius; y <= centerY + radius; y += disturbanceSpacing) {
						const dist = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
						if (dist <= radius) {
							const ripple = Math.cos(dist * 0.3) * (1 - dist/radius) * 1.0;
							
							points.push({
								baseX: x * 0.12,
								baseY: y * 0.12,
								baseZ: ripple,
								gridX: x,
								gridY: y,
								amplitude: 0.5,
								disturbance: i
							});
						}
					}
				}
			}
			
			console.log(`Generated ${points.length} wave surface points (optimized for performance${isMobile ? ', mobile' : ''})`);
			return points;
		}
		
		// Project 3D to 2D screen coordinates
		project3DTo2D(x, y, z) {
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			const scale = Math.min(heroWidth, heroHeight) * 0.15; // Use hero dimensions
			const centerX = heroWidth / 2; // Use hero dimensions
			const centerY = heroHeight / 2;
			
			// Perspective projection - no rotation to prevent gaps
			const distance = 8;
			const projectedScale = scale / (1 + z / distance);
			
			return [
				centerX + x * projectedScale,
				centerY - y * projectedScale,
				z
			];
		}
		
		// Draw point with wave surface appearance - enhanced shadows and contrast
		drawPoint(x, y, z, intensity = 1, pointType = 'normal') {
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// More aggressive culling for performance
			if (x < -10 || x >= heroWidth + 10 || y < -10 || y >= heroHeight + 10) return; // Use hero dimensions
			
			// Simplified point size calculation
			let baseSize = 0.7; // Slightly smaller for performance
			if (pointType === 'secondary') baseSize = 0.5;
			if (pointType === 'disturbance') baseSize = 0.6;
			
			const depthSize = Math.max(0.2, baseSize + (5 - z) * 0.08);
			
			// Enhanced shadow calculation for dramatic fold contrast
			const baseIntensity = intensity * 0.85; // Slightly reduced base for more shadow range
			
			// More dramatic depth-based shadows - deeper valleys get much darker
			const depthFactor = Math.max(0.15, Math.min(1.0, 0.9 - z / 8)); // Increased depth sensitivity
			
			// Secondary shadow based on wave position for fold enhancement
			const foldShadow = Math.max(0.6, 1.0 - Math.abs(z) * 0.3); // Deeper folds get darker
			
			const finalIntensity = baseIntensity * depthFactor * foldShadow;
			
			// Theme-aware point colors
			const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
			let darkness;
			
			if (isDark) {
				// In dark mode, use light colors (inverse of light mode)
				darkness = Math.floor(finalIntensity * 200) + 55; // Range: 55 to 255 (light colors)
			} else {
				// In light mode, use dark colors
				darkness = Math.floor((1 - finalIntensity) * 250) + 5; // Range: 5 to 255 (dark colors)
			}
			
			this.ctx.fillStyle = `rgb(${darkness}, ${darkness}, ${darkness})`;
			this.ctx.globalAlpha = 0.6;
			
			// Draw point - no stroke for performance
			this.ctx.beginPath();
			this.ctx.arc(x, y, depthSize, 0, Math.PI * 2);
			this.ctx.fill();
		}
		
		update() {
			// Performance monitoring
			this.frameCount++;
			const currentTime = performance.now();
			if (currentTime - this.lastTime >= 1000) {
				console.log(`FPS: ${this.frameCount}, Points: ${this.pointCloud.length}`);
				this.frameCount = 0;
				this.lastTime = currentTime;
			}
			
			// Get hero section dimensions
			const heroSection = document.querySelector('.hero');
			const heroWidth = heroSection ? heroSection.offsetWidth : window.innerWidth;
			const heroHeight = heroSection ? heroSection.offsetHeight : window.innerHeight;
			
			// Clear canvas with theme-aware background
			const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
			this.ctx.fillStyle = isDark ? '#0f0f0f' : '#ffffff';
			this.ctx.fillRect(0, 0, heroWidth, heroHeight); // Use hero dimensions
			
			// Apply wave motion to all points - NO ROTATION
			const wavePoints = this.pointCloud.map(point => {
				// Create traveling wave motion with more wave components
				const wavePhase = this.time * 3;
				
				// Multiple wave components for richer motion
				const wave1 = Math.sin(point.gridX * 0.3 + wavePhase) * 0.3;
				const wave2 = Math.cos(point.gridY * 0.25 + wavePhase * 0.8) * 0.25;
				const wave3 = Math.sin((point.gridX + point.gridY) * 0.2 + wavePhase * 1.2) * 0.2;
				const wave4 = Math.cos((point.gridX - point.gridY) * 0.15 + wavePhase * 0.6) * 0.15;
				const wave5 = Math.sin(point.gridX * 0.35 + point.gridY * 0.18 + wavePhase * 1.5) * 0.18;
				const wave6 = Math.cos(point.gridY * 0.28 - point.gridX * 0.12 + wavePhase * 0.9) * 0.12;
				const wave7 = Math.sin((point.gridX * 2 + point.gridY) * 0.08 + wavePhase * 2.0) * 0.1;
				
				// Combine base position with enhanced wave motion
				const flowX = point.baseX;
				const flowY = point.baseY;
				const flowZ = point.baseZ + wave1 + wave2 + wave3 + wave4 + wave5 + wave6 + wave7;
				
				let pointType = 'normal';
				if (point.isSecondary) pointType = 'secondary';
				if (point.disturbance !== undefined) pointType = 'disturbance';
				
				return {
					x: flowX,
					y: flowY,
					z: flowZ,
					pointType: pointType
				};
			});
			
			// Project to 2D with aggressive culling for performance
			const projectedPoints = wavePoints.map(point => {
				const [x, y, z] = this.project3DTo2D(point.x, point.y, point.z);
				return {
					x, y, z,
					pointType: point.pointType
				};
			}).filter(point => {
				// Very aggressive culling for performance
				return point.x > -30 && point.x < heroWidth + 30 && 
				       point.y > -30 && point.y < heroHeight + 30;
			}).sort((a, b) => a.z - b.z);
			
			// Draw all points with simplified intensity calculation
			for (const point of projectedPoints) {
				// Simplified pulse calculation for performance
				const pulse = 0.7 + Math.sin(this.time * 2 + point.x * 0.005 + point.y * 0.005) * 0.3;
				
				this.drawPoint(point.x, point.y, point.z, pulse, point.pointType);
			}
			
			// Reset alpha
			this.ctx.globalAlpha = 1;
			
			// Update time
			this.time += this.waveSpeed;
		}
		
		animate() {
			this.update();
			requestAnimationFrame(() => this.animate());
		}
	}
	
	// Initialize when page loads
	document.addEventListener('DOMContentLoaded', () => {
		new FlowingPointCloud();
		
		// Initialize cyclical description animation
		initDescriptionCycle();
		
		// Initialize border management for latest research grid
		initLatestResearchBorders();
	});
	
	function initDescriptionCycle() {
		const descriptions = [
			document.getElementById('domain-text'),
			document.getElementById('investment-text'),
			document.getElementById('relationships-text'),
			document.getElementById('stanford-text')
		];
		
		const circles = [
			document.getElementById('domain-circle'),
			document.getElementById('investment-circle'),
			document.getElementById('relationships-circle'),
			document.getElementById('stanford-circle')
		];
		
		if (!descriptions[0] || !circles[0]) return;
		
		let currentIndex = 0;
		
		function showDescription(index) {
			// First, mark current active description as exiting
			const currentActive = descriptions.find(desc => desc && desc.classList.contains('active'));
			if (currentActive) {
				currentActive.classList.remove('active');
				currentActive.classList.add('exiting');
			}
			
			// Fade out all circles first for smoother transition
			circles.forEach((circle, i) => {
				if (circle) {
					circle.style.opacity = '0.3';
					circle.style.strokeWidth = '1';
				}
			});
			
			// Reset all other descriptions
			descriptions.forEach((desc, i) => {
				if (desc && desc !== currentActive) {
					desc.classList.remove('active', 'exiting');
				}
			});
			
			// Activate new description and circle after a brief delay for smooth transition
			setTimeout(() => {
				if (descriptions[index]) {
					descriptions[index].classList.remove('exiting');
					descriptions[index].classList.add('active');
				}
				
				// Fade in all inactive circles to normal state
				circles.forEach((circle, i) => {
					if (circle && i !== index) {
						circle.style.opacity = '0.7';
						circle.style.strokeWidth = '1';
					}
				});
				
				// Fade in active circle to bold state
				if (circles[index]) {
					circles[index].style.opacity = '1';
					circles[index].style.strokeWidth = '3';
				}
			}, 500); // Longer delay for smoother transition flow
		}
		
		// Start the cycle
		showDescription(currentIndex);
		
		setInterval(() => {
			currentIndex = (currentIndex + 1) % descriptions.length;
			showDescription(currentIndex);
		}, 6500); // Change every 5 seconds
	}
	
	function initLatestResearchBorders() {
		const articleCards = document.querySelectorAll('.latest-research-section .article-card');
		
		function updateBorders() {
			// Remove all border classes first
			articleCards.forEach(card => {
				card.classList.remove('no-right-border', 'no-bottom-border');
			});

			// Get visible cards (all are visible in this case)
			const visibleCards = Array.from(articleCards);

			// Apply borders to visible cards
			visibleCards.forEach((card, index) => {
				// Remove right border from every 3rd visible item (last column)
				if ((index + 1) % 3 === 0) {
					card.classList.add('no-right-border');
				}
				
				// Remove bottom border from last row
				const totalVisible = visibleCards.length;
				const lastRowStart = Math.floor((totalVisible - 1) / 3) * 3;
				if (index >= lastRowStart) {
					card.classList.add('no-bottom-border');
				}
			});
		}
		
		updateBorders();
	}
</script>

<style>
	.main {
		margin: 0;
		padding: 0;
	}
	
	.hero {
		position: relative;
		height: calc(100vh - 80px); /* Use height instead of min-height for exact sizing */
		overflow: hidden;
		margin: 0;
		padding: 0;
	}
	
	.tesseract-container {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 1;
		pointer-events: none;
	}
	
	#tesseract-canvas {
		width: 100%;
		height: 100%;
		display: block;
	}
	
	.hero-container {
		width: 100%;
		max-width: 1200px;
		margin: 0 auto;
		padding: 0 var(--spacing-lg);
		position: relative;
		z-index: 10;
		height: 100%; /* Add this so percentage-based positioning works */
	}
	
	.hero-content {
		max-width: 800px;
		margin-left: 16.5%;
		margin-top: 29vh;
		position: relative;
	}
	
	.hero-title {
		font-size: 3rem;
		font-weight: 700;
		line-height: 1.1;
		margin-bottom: var(--spacing-xl);
		color: var(--text-primary);
	}
	
	.hero-subtitle {
		font-size: 1.3rem;
		line-height: 1.6;
		color: var(--text-secondary);
		margin: 0;
	}
	
	/* Mobile devices - optimized layout */
	@media (max-width: 768px) {
		.hero {
			height: calc(100vh - 80px);
			padding: 0;
			display: flex;
			align-items: center;
		}
		
		.hero-container {
			padding: 0 var(--spacing-md);
			width: 100%;
		}
		
		.hero-content {
			max-width: 90%;
			margin-left: 5%;
			margin-top: 20vh;
			text-align: left;
			padding: 0;
		}
		
		.hero-title {
			font-size: 2rem;
			line-height: 1.2;
			margin-bottom: var(--spacing-lg);
		}
		
		.hero-subtitle {
			font-size: 1.1rem;
			line-height: 1.5;
		}
		
		/* Keep animation but optimize for mobile performance */
		.tesseract-container {
			display: block;
		}
		
		.main {
			background: var(--bg-white);
		}
	}
	
	/* Small phones */
	@media (max-width: 480px) {
		.hero {
			padding: var(--spacing-lg) 0;
		}
		
		.hero-title {
			font-size: 1.6rem;
			margin-bottom: var(--spacing-md);
		}
		
		.hero-subtitle {
			font-size: 1rem;
			line-height: 1.4;
		}
		
		.hero-container {
			padding: 0 var(--spacing-sm);
		}
		
		.hero-content {
			max-width: 95%;
			margin-left: 2.5%;
			padding: 0;
		}
	}
	
	/* Team CTA Section */
	.team-cta-section {
		background: #000000; /* Pure black */
		color: #ffffff; /* Pure white text */
		padding: var(--spacing-lg) 0; /* Much smaller padding */
	}
	
	.team-cta-container {
		max-width: 1200px;
		margin: 0 auto;
		padding: var(--spacing-3xl) var(--spacing-lg); /* Even more vertical padding */
		text-align: center;
	}
	
	.team-cta-content {
		max-width: 800px;
		margin: 0 auto;
	}
	
	.team-cta-text {
		font-size: 1.3rem; /* Match hero subtitle font size */
		line-height: 1.6; /* Match hero subtitle line height */
		margin: 0 0 var(--spacing-xl) 0;
		font-weight: 400;
		color: inherit; /* Use inherited color from section */
	}
	
	.team-cta-button {
		display: inline-flex;
		align-items: center;
		padding: 8px 20px; /* Match filter button padding */
		background: transparent; /* Transparent background like filter buttons */
		color: #ffffff; /* White text on black background */
		text-decoration: none;
		border-radius: 25px; /* Match filter button border radius */
		font-weight: 500; /* Match filter button font weight */
		font-size: 14px; /* Match filter button font size */
		transition: all 0.2s ease;
		border: 1px solid #ffffff; /* White border on black background */
	}
	
	.team-cta-button:hover {
		background: #ffffff; /* White background on hover */
		color: #000000; /* Black text on hover */
		border-color: #ffffff;
	}
	
	/* Mobile styles for team CTA */
	@media (max-width: 768px) {
		.team-cta-section {
			padding: var(--spacing-2xl) 0;
		}
		
		.team-cta-container {
			padding: 0 var(--spacing-md);
		}
		
		.team-cta-text {
			font-size: 1.1rem; /* Match mobile hero subtitle font size */
			line-height: 1.5; /* Match mobile hero subtitle line height */
		}
		
		.team-cta-button {
			padding: 14px var(--spacing-lg);
			font-size: 0.9rem;
		}
		
		.venn-diagram {
			margin-top: var(--spacing-lg);
			max-width: 420px; /* Back to original mobile size */
			margin-left: 0; /* Keep left aligned on mobile */
		}
		
		.venn-content {
			flex-direction: column;
			gap: var(--spacing-md);
		}
		
		.venn-visual, .venn-text {
			flex: none;
			width: 100%;
		}
		
		.venn-description {
			padding: var(--spacing-sm);
		}
		
		.venn-description p {
			font-size: 0.85rem;
		}
		
		.venn-label {
			font-size: 12px; /* Proportionally smaller for mobile, but same for all labels */
		}
		
		.venn-center-label {
			font-size: 12px; /* Same as other labels on mobile */
		}
	}
	
	@media (max-width: 480px) {
		.team-cta-container {
			padding: 0 var(--spacing-sm);
		}
		
		.team-cta-text {
			font-size: 1.1rem;
		}
		
		.venn-diagram {
			max-width: 350px; /* Back to original small phone size */
			margin-left: 0; /* Keep left aligned */
		}
		
		.venn-description {
			padding: var(--spacing-xs);
		}
		
		.venn-description p {
			font-size: 0.8rem;
			line-height: 1.4;
		}
		
		.venn-label {
			font-size: 11px; /* Proportionally larger for small phones */
		}
		
		.venn-center-label {
			font-size: 10px; /* Small center text on small phones */
		}
	}

	/* Venn Diagram Styles */
	.venn-diagram {
		margin-top: var(--spacing-sm);
		width: fit-content; /* Exactly the width of content */
		margin-left: 0;
		margin-right: auto;
		display: block;
	}

	.venn-content {
		display: flex;
		align-items: flex-start;
		gap: 5px;
		width: fit-content; /* No excess width */
	}

	.venn-visual {
		flex: 0 0 360px; /* Much smaller diagram - reduced from 560px */
		position: relative;
	}

	.venn-text {
		flex: 0 0 480px; /* Much smaller fixed width */
		position: relative;
		min-height: 400px; /* Increased from 200px for better animation space */
		overflow: hidden; /* Hide text that goes beyond container boundaries */
		clip-path: inset(40px 0 0 0); /* Clip from 150px down - same level as Venn diagram top */
	}

	.venn-description {
		position: absolute;
		top: 40px; /* Move descriptions down within the container */
		left: 0;
		width: 100%;
		background: rgba(0, 0, 0, 0.8);
		padding: var(--spacing-2xl);
		transition: transform 2.5s cubic-bezier(0.165, 0.84, 0.44, 1), opacity 1.5s ease;
		opacity: 0;
		transform: translateY(100%); /* Start completely below the container */
		backdrop-filter: blur(8px);
		text-align: left;
	}

	.venn-description.active {
		opacity: 1;
		transform: translateY(0); /* Slide to normal position */
	}

	/* Create a smooth scroll-like exit */
	.venn-description.exiting {
		opacity: 0;
		transform: translateY(-100%); /* Continue scrolling upward out of view */
		transition: transform 4s cubic-bezier(0.165, 0.84, 0.44, 1), opacity 2s ease;
	}

	.venn-description p {
		font-size: 1.2rem;
		line-height: 1.7;
		color: #ffffff;
		margin: 0;
	}

	.venn-svg {
		width: 100%;
		height: auto;
	}

	.venn-circle {
		fill: none; /* Transparent fill */
		stroke: #ffffff; /* White border on black background */
		stroke-width: 1; /* Match button border width */
		opacity: 0.7;
		transition: opacity 0.8s ease, stroke-width 0.8s ease;
	}

	.venn-circle:hover {
		opacity: 1;
	}

	.venn-label {
		font-size: 15px; /* Same size as center label */
		font-weight: 600;
		fill: #ffffff; /* White text on black background */
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
	}

	.venn-center {
		fill: #ffffff; /* White fill for center circle */
		stroke: #ffffff; /* White border */
		stroke-width: 1; /* Match button and outer circles */
		opacity: 1; /* Fully opaque */
	}

	.venn-center-label {
		font-size: 15px; /* Same as other labels */
		font-weight: 600; /* Same weight as other labels */
		fill: #000000; /* Black text on white center circle */
		text-anchor: middle;
		dominant-baseline: middle;
		pointer-events: none;
	}

	/* Latest Research Section */
	.latest-research-section {
		background: var(--bg-white); /* White background in light mode */
		color: var(--text-primary); /* Dark text in light mode */
		padding: var(--spacing-lg) 0;
		padding-bottom: var(--spacing-xl);
	}

	.container {
		background: var(--bg-white);
		max-width: 1180px;
		padding: 0 60px;
		margin: 0 auto;
	}

	.latest-research-content {
		text-align: center;
	}

	.latest-research-title {
		font-size: 2.5rem;
		font-weight: 700;
		line-height: 1.1;
		margin-bottom: var(--spacing-xl);
		color: var(--text-primary);
		text-align: center;
	}

	.latest-research-button {
		display: inline-flex;
		align-items: center;
		padding: 8px 20px;
		background: transparent;
		color: var(--text-primary);
		text-decoration: none;
		border-radius: 25px;
		font-weight: 500;
		font-size: 14px;
		transition: all 0.2s ease;
		border: 1px solid var(--text-primary);
		margin-bottom: var(--spacing-xl);
	}

	.latest-research-button:hover {
		background: var(--text-primary);
		color: var(--bg-white);
		border-color: var(--text-primary);
	}

	.articles-grid {
		display: grid;
		grid-template-columns: repeat(3, 1fr);
		gap: 0;
		border: 1px solid var(--border-color);
		background: var(--bg-white);
		width: 100%;
		align-items: stretch;
		margin-bottom: var(--spacing-xl);
	}

	.articles-grid :global(.article-card) {
		background: var(--bg-white);
		color: var(--text-primary);
		border: none;
		border-radius: 0;
		margin: 0;
		padding: 30px;
		border-right: 1px solid var(--border-color);
		border-bottom: 1px solid var(--border-color);
		transition: background-color 0.2s ease;
		min-height: 400px;
		display: flex;
		flex-direction: column;
		cursor: pointer;
		height: 100%;
		position: relative;
	}

	.articles-grid :global(.article-card:hover) {
		background: var(--bg-light);
		transform: none;
		box-shadow: none;
	}

	.articles-grid :global(.article-card .article-title) {
		color: var(--text-primary);
		font-size: 1.4rem;
		line-height: 1.3;
	}

	.articles-grid :global(.article-card .article-title a) {
		color: var(--text-primary);
		text-decoration: none;
	}

	.articles-grid :global(.article-card .article-title a:hover) {
		color: var(--text-secondary);
	}

	.articles-grid :global(.article-excerpt) {
		color: var(--text-secondary);
		font-size: 0.9rem;
		line-height: 1.5;
	}

	.articles-grid :global(.tag) {
		background: var(--bg-light);
		color: var(--text-primary);
		border: 1px solid var(--border-color);
		font-size: 0.75rem;
		padding: 3px 6px;
	}

	.articles-grid :global(.tag:hover) {
		background: var(--text-primary);
		color: var(--bg-white);
		border-color: var(--text-primary);
	}

	.articles-grid :global(.article-meta) {
		color: var(--text-secondary);
		font-size: 0.8rem;
		padding-top: 16px;
		border-top: 1px solid var(--border-color);
		display: flex;
		justify-content: space-between;
		align-items: center;
		gap: 12px;
	}

	.articles-grid :global(.article-meta svg) {
		color: var(--text-secondary);
	}

	.articles-grid :global(.article-date) {
		display: flex;
		align-items: center;
		gap: 6px;
	}

	.articles-grid :global(.reading-time) {
		font-weight: 500;
	}

	/* Dynamic border removal classes */
	.articles-grid :global(.article-card.no-right-border) {
		border-right: none;
	}

	.articles-grid :global(.article-card.no-bottom-border) {
		border-bottom: none;
	}

	/* Dark mode styles for latest research section */
	[data-theme="dark"] .latest-research-section {
		background: var(--bg-white) !important; /* Black background in dark mode */
		color: var(--text-primary) !important; /* Light text in dark mode */
	}

	[data-theme="dark"] .research-card {
		background: var(--bg-light) !important;
		border-color: var(--border-color) !important;
	}

	[data-theme="dark"] .research-card:hover {
		box-shadow: 0 8px 25px rgba(255, 255, 255, 0.1) !important;
	}

	[data-theme="dark"] .research-category {
		background: var(--primary-color) !important;
		color: var(--bg-white) !important;
	}

	[data-theme="dark"] .research-card-link {
		background: var(--primary-color) !important;
		color: var(--bg-white) !important;
	}

	[data-theme="dark"] .research-card-link:hover {
		background: var(--primary-hover) !important;
	}

	[data-theme="dark"] .research-view-all-btn {
		background: var(--primary-color) !important;
		color: var(--bg-white) !important;
	}

	[data-theme="dark"] .research-view-all-btn:hover {
		background: var(--primary-hover) !important;
	}

	/* Mobile styles for latest research */
	@media (max-width: 768px) {
		.container {
			max-width: 100%;
			padding: 0 var(--spacing-md);
		}
		
		.latest-research-section {
			padding: var(--spacing-md) 0 var(--spacing-2xl);
		}

		.latest-research-title {
			font-size: 2rem;
			margin-bottom: var(--spacing-lg);
		}

		.latest-research-button {
			font-size: 0.9rem;
			padding: 14px var(--spacing-lg);
		}

		.articles-grid {
			grid-template-columns: 1fr;
			gap: var(--spacing-md);
			border: none;
			padding-bottom: var(--spacing-2xl);
		}

		.articles-grid :global(.article-card) {
			border: 1px solid var(--border-color);
			border-radius: 8px;
			padding: var(--spacing-lg);
			margin-bottom: 0;
		}

		.articles-grid :global(.article-card:hover) {
			transform: none;
		}

		.articles-grid :global(.article-card .article-title) {
			font-size: 1.2rem;
		}

		.articles-grid :global(.article-excerpt) {
			font-size: 0.85rem;
		}

		.articles-grid :global(.article-meta) {
			font-size: 0.75rem;
			flex-direction: column;
			align-items: flex-start;
			gap: var(--spacing-xs);
		}

		.articles-grid :global(.tag) {
			font-size: 0.7rem;
			padding: 2px 6px;
		}
	}

	@media (max-width: 480px) {
		.container {
			padding: 0 var(--spacing-sm);
		}

		.latest-research-title {
			font-size: 1.8rem;
		}

		.latest-research-button {
			font-size: 12px;
			padding: 6px 16px;
		}

		.articles-grid :global(.article-card) {
			padding: var(--spacing-md);
		}

		.articles-grid :global(.article-card .article-title) {
			font-size: 1.1rem;
		}
	}
</style>
